<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用feign上传下载文件扩展包填坑记]]></title>
    <url>%2F2018%2F04%2F04%2F%E4%BD%BF%E7%94%A8fegin%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%8C%85%E5%A1%AB%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[问题描述先把有坑的代码贴上：12345678910//...上下文我就省略了，把有问题的代码段贴出来InputStream inputStream = null;inputStream = fresp.body().asInputStream();FileTypeJudger.FileInfo fileInfo = fileTypeJudger.judgeToFileInfo(inputStream);mimeType = fileInfo.getMimeType();// 必须将游标设置到起始位置，才能输出完整的文件流inputStream.reset(); //这里就是有坑的地方//... 以上代码在最后一行会抛出如下异常：1java.io.IOException: mark/reset not supported 但是我在开发和测试环境都验证过，fresp.body().asInputStream()返回的是ByteArrayInputStream类型，也就是说最后一行是支持reset操作的。 排查记录 查看feign源码发现asInputStream()方法有两个实现，分别是ByteArrayBody和InputStreamBody，源码如下： 1234567891011// ByteArrayBody实现@Overridepublic InputStream asInputStream() throws IOException &#123; return new ByteArrayInputStream(data);&#125;// InputStreamBody实现@Overridepublic InputStream asInputStream() throws IOException &#123; return inputStream;&#125; 可以看出只有调用InputStreamBody实现的asInputStream()方法才会出现上面的异常。 然后在本地发起请求，开启debug模式，一步一步跟发现没有问题，每次都是走到ByteArrayBody，这让我郁闷了很长时间啊。 然后尝试跟踪ByteArrayInputStream实例中传递的data的初始化流程。发现是在ByteArrayBody类的构造函数中初始化的。 1234// 构造函数public ByteArrayBody(byte[] data) &#123; this.data = data;&#125; 再跟踪构造函数，发现在orNull()方法中被调用了 1234567// orNull 方法private static Body orNull(byte[] data) &#123; if (data == null) &#123; return null; &#125; return new ByteArrayBody(data);&#125; 再跟踪orNull()方法，发现在Response.Builder类中的被调用，调用方法如下： 1234public Builder body(byte[] data) &#123; this.body = ByteArrayBody.orNull(data); return this;&#125; 再跟踪body()方法，发现有两个地方会调用，Logger和SynchronousMethodHandler两个类中会调用。 然后先在SynchronousMethodHandler的方法中debug，代码片段如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283@Overridepublic Object invoke(Object[] argv) throws Throwable &#123; RequestTemplate template = buildTemplateFromArgs.create(argv); Retryer retryer = this.retryer.clone(); while (true) &#123; try &#123; return executeAndDecode(template); &#125; catch (RetryableException e) &#123; retryer.continueOrPropagate(e); if (logLevel != Logger.Level.NONE) &#123; logger.logRetry(metadata.configKey(), logLevel); &#125; continue; &#125; &#125;&#125;Object executeAndDecode(RequestTemplate template) throws Throwable &#123; Request request = targetRequest(template); if (logLevel != Logger.Level.NONE) &#123; logger.logRequest(metadata.configKey(), logLevel, request); &#125; Response response; long start = System.nanoTime(); try &#123; response = client.execute(request, options); // ensure the request is set. TODO: remove in Feign 10 response.toBuilder().request(request).build(); &#125; catch (IOException e) &#123; if (logLevel != Logger.Level.NONE) &#123; logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start)); &#125; throw errorExecuting(request, e); &#125; long elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start); boolean shouldClose = true; try &#123; if (logLevel != Logger.Level.NONE) &#123; response = logger.logAndRebufferResponse(metadata.configKey(), logLevel, response, elapsedTime); // ensure the request is set. TODO: remove in Feign 10 response.toBuilder().request(request).build(); &#125; if (Response.class == metadata.returnType()) &#123; if (response.body() == null) &#123; return response; &#125; if (response.body().length() == null || response.body().length() &gt; MAX_RESPONSE_BUFFER_SIZE) &#123; shouldClose = false; return response; &#125; // Ensure the response body is disconnected byte[] bodyData = Util.toByteArray(response.body().asInputStream()); // 此处就是调用body方法的地方，断点打到这里，在实际debug过程中发现并没有走到这里 return response.toBuilder().body(bodyData).build(); &#125; if (response.status() &gt;= 200 &amp;&amp; response.status() &lt; 300) &#123; if (void.class == metadata.returnType()) &#123; return null; &#125; else &#123; return decode(response); &#125; &#125; else if (decode404 &amp;&amp; response.status() == 404 &amp;&amp; void.class != metadata.returnType()) &#123; return decode(response); &#125; else &#123; throw errorDecoder.decode(metadata.configKey(), response); &#125; &#125; catch (IOException e) &#123; if (logLevel != Logger.Level.NONE) &#123; logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime); &#125; throw errorReading(request, response, e); &#125; finally &#123; if (shouldClose) &#123; ensureClosed(response.body()); &#125; &#125;&#125; 然后在Logger的方法中debug，代码片段如下： 123456789101112131415161718192021222324252627282930313233343536protected Response logAndRebufferResponse(String configKey, Level logLevel, Response response, long elapsedTime) throws IOException &#123; String reason = response.reason() != null &amp;&amp; logLevel.compareTo(Level.NONE) &gt; 0 ? " " + response.reason() : ""; int status = response.status(); log(configKey, "&lt;--- HTTP/1.1 %s%s (%sms)", status, reason, elapsedTime); if (logLevel.ordinal() &gt;= Level.HEADERS.ordinal()) &#123; for (String field : response.headers().keySet()) &#123; for (String value : valuesOrEmpty(response.headers(), field)) &#123; log(configKey, "%s: %s", field, value); &#125; &#125; int bodyLength = 0; if (response.body() != null &amp;&amp; !(status == 204 || status == 205)) &#123; // HTTP 204 No Content "...response MUST NOT include a message-body" // HTTP 205 Reset Content "...response MUST NOT include an entity" if (logLevel.ordinal() &gt;= Level.FULL.ordinal()) &#123; log(configKey, ""); // CRLF &#125; byte[] bodyData = Util.toByteArray(response.body().asInputStream()); bodyLength = bodyData.length; if (logLevel.ordinal() &gt;= Level.FULL.ordinal() &amp;&amp; bodyLength &gt; 0) &#123; log(configKey, "%s", decodeOrDefault(bodyData, UTF_8, "Binary data")); &#125; log(configKey, "&lt;--- END HTTP (%s-byte body)", bodyLength); // 此处会调用body方法，并且我在本地调试的时候确实会走到此处 return response.toBuilder().body(bodyData).build(); &#125; else &#123; log(configKey, "&lt;--- END HTTP (%s-byte body)", bodyLength); &#125; &#125; return response;&#125; 最后发现，原来我之前在开发和测试环境一直配置的日志打印级别都是debug，feign中的日志只有配置了debug级别才会输出，上面的代码其实就是当判断需要输出日志时，会先把输入流转成byte array缓存起来，并且会封装成ByteArrayBody方便后续复用该流。生产上面配置的日志级别是info，所以会封装成InputStreamBody，也就导致后续获取的输入流是不支持mark的。 解决方案123456789101112131415//...上下文我就省略了，把有问题的代码段贴出来InputStream inputStream = null;inputStream = fresp.body().asInputStream();Util.checkNotNull(inputStream, "inputstream from edfs is null");// 校验流是否支持标记if (!inputStream.markSupported()) &#123; inputStream = new ByteArrayInputStream(Util.toByteArray(inputStream));&#125;FileTypeJudger.FileInfo fileInfo = fileTypeJudger.judgeToFileInfo(inputStream);mimeType = fileInfo.getMimeType();// 必须将游标设置到起始位置，才能输出完整的文件流inputStream.reset();//...]]></content>
      <categories>
        <category>feign</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>feign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八大排序算法的java实现]]></title>
    <url>%2F2017%2F02%2F17%2F8-sort-arithmetic-of-java%2F</url>
    <content type="text"><![CDATA[每当提到算法，自然少不了各种排序算法，例如冒泡排序，快速排序等等。这篇文章将会介绍用java来实现各种排序算法，一来是自己再巩固一下这一块知识的，二来是将这块知识分享给大家，希望大家和我一起进步。 插入排序 基本思想：假设有一组个数为n的数，从第二数开始，按照比较规则插入到之前的数中，这样前面两个数就已经是排好序的，然后在从第三个数开始按照同样的规则插入到之前的数中，依次类推直到操作到第n个数。 下面是具体实现源码：123456789101112131415public static void insertionSort(int[] arr) &#123; int j; for(int i = 1; i &lt; arr.length; i++) &#123; int tmp = arr[i]; for(j = i; j &gt; 0; j--) &#123; if ( tmp &lt; arr[j - 1]) &#123; arr[j] = arr[j - 1]; &#125; else &#123; break; &#125; &#125; arr[j] = tmp; &#125;&#125; 希尔排序 基本思想：算法先将要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。 下面是具体实现源码：1234567891011121314151617181920public static void shellSort(int[] arr) &#123; int d1 = arr.length; while (true) &#123; d1 = (int) Math.ceil(d1 / 2); int d = d1; for (int x = 0; x &lt; d; x++) &#123; for (int i = x + d;i &lt; arr.length;i += d)&#123; int j = i - d; int temp = arr[i]; for (; j &gt;= 0 &amp;&amp; temp &lt; arr[j]; j -= d) &#123; arr[j+d] =arr[j]; &#125; arr[j+d] = temp; &#125; &#125; if (d == 1) &#123; break; &#125; &#125;&#125; 简单选择排序 基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。 下面是具体实现源码：1234567891011public static void selectSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[i]) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125; &#125; &#125;&#125; 堆排序 基本思想：堆排序是一种树形选择排序，是对直接选择排序的有效改进。堆的定义如下：具有n个元素的序列（h1,h2,…,hn),当且仅当满足（hi&gt;=h2i,hi&gt;=2i+1）或（hi&lt;=h2i,hi&lt;=2i+1） (i=1,2,…,n/2)时称之为堆。在这里只讨论满足前者条件的堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。完全二叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。 下面是具体实现源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class HeapSort &#123; public void heapSort(int[] a) &#123; int arrayLength = a.length; //循环建堆 for(int i = 0; i &lt; arrayLength - 1; i++)&#123; //建堆 buildMaxHeap(a, arrayLength - 1 - i); //交换堆顶和最后一个元素 swap(a, 0, arrayLength - 1 - i); &#125; &#125; //交换位置 private void swap(int[] data, int i, int j) &#123; int tmp = data[i]; data[i] = data[j]; data[j] = tmp; &#125; //建堆 private void buildMaxHeap(int[] data, int lastIndex) &#123; //从lastIndex处节点（最后一个节点）的父节点开始 for (int i = (lastIndex - 1) / 2; i &gt;= 0; i--) &#123; //k保存正在判断的节点 int k = i; //如果当前k节点的子节点存在 while (k * 2 + 1 &lt;= lastIndex) &#123; //k节点的左子节点的索引 int biggerIndex = 2 * k + 1; //如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在 if (biggerIndex &lt; lastIndex) &#123; //若果右子节点的值较大 if (data[biggerIndex] &lt; data[biggerIndex + 1]) &#123; //biggerIndex总是记录较大子节点的索引 biggerIndex++; &#125; &#125; //如果k节点的值小于其较大的子节点的值 if (data[k] &lt; data[biggerIndex]) &#123; //交换他们 swap(data, k, biggerIndex); //将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值 k = biggerIndex; &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125; 冒泡排序 基本思想：假设有一个长度为n的数组，从第一个位置开始，每两个相邻的位置的数值进行比较，如果前面一个位置的数值比后面一个位置的数值大，就交换这两个位置的数值，当最后一对数比较完毕之后，最后一个位置的数值就是最大值。然后我们再以相同的步骤操作数组中除了最后一个位置的所有值，直到没有任何一对数值需要比较。 下面是具体实现源码：1234567891011public static void bubbleSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; &#125; &#125;&#125; 快速排序 基本思想：假设有一个长度为n的集合，将中间的元素作为中轴，把集合中的所有小于该中轴的元素放在中轴左边，把集合中的所有大于该中轴的元素放在右边，然后在以相同的逻辑分别处理中轴左边和右边的集合，依次递归，直到中轴左边和右边的元素个数都为1。 下面是具体实现代码：1234567891011121314151617181920212223242526public static void fastSort(List&lt;Integer&gt; items) &#123; if (items.size() &gt; 1) &#123; List&lt;Integer&gt; smaller = new ArrayList&lt;&gt;(); List&lt;Integer&gt; same = new ArrayList&lt;&gt;(); List&lt;Integer&gt; larger = new ArrayList&lt;&gt;(); Integer chosenItem = items.get(items.size() / 2); for (Integer item : items) &#123; if (item &lt; chosenItem) &#123; smaller.add(item); &#125; else if (item &gt; chosenItem) &#123; larger.add(item); &#125; else &#123; same.add(item); &#125; &#125; fastSort(smaller); fastSort(larger); items.clear(); items.addAll(smaller); items.addAll(same); items.addAll(larger); &#125;&#125; 归并排序 基本思想：归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。 下面是具体实现代码：1234567891011121314151617181920212223242526272829303132333435public class MergeSort &#123; public static void sort(int data[], int start, int end) &#123; if (start &lt; end) &#123; int mid = (start + end) / 2; sort(data, start, mid); sort(data, mid + 1, end); merge(data, start, mid, end); &#125; &#125; public static void merge(int data[], int start, int mid, int end) &#123; int temp[] = new int[end - start + 1]; int i = start; int j = mid + 1; int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= end) &#123; if (data[i] &lt; data[j]) &#123; temp[k++] = data[i++]; &#125; else &#123; temp[k++] = data[j++]; &#125; &#125; while (i &lt;= mid) &#123; temp[k++] = data[i++]; &#125; while (j &lt;= end) &#123; temp[k++] = data[j++]; &#125; for (k = 0, i = start; k &lt; temp.length; k++, i++) &#123; data[i] = temp[k]; &#125; &#125;&#125; 基数排序 基本思想：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。 下面是具体实现代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static class radixSort &#123; public void sort(int[] array) &#123; //首先确定排序的趟数; int max = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; &#125; int time = 0; //判断位数; while (max &gt; 0) &#123; max /= 10; time++; &#125; //建立10个队列; List&lt;ArrayList&gt; queue = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; ArrayList&lt;Integer&gt; queue1 = new ArrayList&lt;&gt;(); queue.add(queue1); &#125; //进行time次分配和收集; for (int i = 0; i &lt; time; i++) &#123; //分配数组元素; for (int j = 0; j &lt; array.length; j++) &#123; //得到数字的第time+1位数; int x = array[j] % (int) Math.pow(10, i + 1) / (int) Math.pow(10, i); ArrayList&lt;Integer&gt; queue2 = queue.get(x); queue2.add(array[j]); queue.set(x, queue2); &#125; int count = 0;//元素计数器; //收集队列元素; for (int k = 0; k &lt; 10; k++) &#123; while (queue.get(k).size() &gt; 0) &#123; ArrayList&lt;Integer&gt; queue3 = queue.get(k); array[count] = queue3.get(0); queue3.remove(0); count++; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客从使用Hexo搭建博客开始]]></title>
    <url>%2F2017%2F02%2F04%2Fmy-first-blog-start-with-build-blog-using-hexo%2F</url>
    <content type="text"><![CDATA[Hexo是一款快速、简洁且高效的博客框架，用它来搭建自己的个人博客是一个不错的选择。这篇文章主要介绍我是如何使用该框架来搭建自己的个人博客。 Hexo安装及相关配置安装Hexo安装很简单，mac和windows都有详细的安装教程，这里提供一个hexo官方详细的安装教程链接。 打开本地终端，然后执行以下命令，初始化工作目录123$ hexo init &lt;folder-path&gt;$ cd &lt;folder-path&gt;$ npm install 执行完以上命令之后，工作目录就初始化完成了。 配置进入工作目录会发现有一个_config.yml的文件，配置就是在这个文件中添加和修改的。 这里简单介绍一下几个常用的参数： 参数名 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 你的名字 language 网站使用的语言，例如zh-Hans就是指中文 timezone 网站时区，例如Asia/Shanghai就是指上海时区 theme 网站主题，使用之前需要先安装 avatar 你的头像 favicon 网页tag的小图标 这些知识简单介绍一下，具体的配置说明详见Hexo官方配置说明 Hexo主题Next安装及相关配置安装打开终端，执行如下命令：12$ cd &lt;folder-path&gt;$ git clone https://github.com/iissnan/hexo-theme-next themes/next 命令执行完成之后，编辑_config.yml文件，将theme参数的修改成next。 然后执行如下命令，清除Hexo缓存：1$ hexo clean 配置Next主题也有很多配置参数，这里我还是简单介绍一些常用的： 参数名 描述 scheme 外观配置，支持三种（Muse,Mist,Pisces） language 网站语言，和Hexo中的类似 menu 菜单配置 具体的配置说明详见Next官方配置说明。 将网站托管到github上创建仓库github中创建一个仓库这里就不详细说明了，把几点注意事项说明一下： 仓库必须是public的 仓库名称要以yourname.github.io的格式命名 将本地机器的公钥添加到你的github中 关联本地网站到github仓库中在Hexo的配置文件_config.yml中修改如下配置：1234deploy: type: git repository: &lt;你的github新建的仓库地址&gt; branch: master 修改完成之后，我们可以打开终端执行如下命令：123$ hexo clean$ hexo g$ hexo d 将网站部署到github中。 部署完成之后你可以通过访问 https://yourname.github.io 地址，如果能够访问，说明你在本地配置好的网站已经成功部署到github中了。 如何对本地网站进行版本控制进过如上步骤之后你的网站已经成功部署到github中了，但是如果对你的网站进行版本控制呢？ 我是参考利用git解决hexo博客多PC间同步问题这篇博客的做法：利用oschina的私有仓库来进行版本控制，在网站工作根路径下将该目录重新初始化成本地git仓库，然后将本地仓库提交到oschina的私有仓库中。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
