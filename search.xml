<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[go-micro学习笔记]]></title>
    <url>%2F2019%2F01%2F06%2Fgo-micro%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[特性 micro toolkit 问题 使用 如何使用 安装服务注册发现中心 服务端 客户端 踩过的坑 参考文档 特性服务发现 自动服务注册和发现。默认使用consul作为服务发现和注册中心，可通过插件化修改为其他的注册中心，比如etcd，zookeeper等。 负载均衡 基于服务发现的客户端负载平衡。 消息编码 基于内容类型的动态消息编码。 客户端和服务器将根据内容类型使用对应的编解码器。 同步流 基于RPC的请求/响应，支持双向流。提供了同步通讯的抽象。向服务发出的请求将被自动解析、负载平衡、拨号和流处理。 默认值启用tls时，transport为http / 1.1或http2。 异步消息 PubSub是作为异步通信和事件驱动架构的一等公民而构建的。事件通知是微服务开发的核心模式。启用tls时，默认消息传递是点对点http1.1或http2。 可插拔接口 Go Micro为每个分布式系统抽象出Go接口。这些接口是可插拔的，并且允许Go Micro不依赖于运行时。您可以插入任何底层技术。 micro toolkitmicro是一个工具包。提供了一些工具方便在go-micro微服务架构中使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869~ micro -hNAME: micro - A cloud-native toolkitUSAGE: micro [global options] command [command options] [arguments...]VERSION: 0.13.0COMMANDS: api Run the micro API bot Run the micro bot cli Start the interactive cli registry Query registry call Call a service or function query Deprecated: Use call instead stream Create a service or function stream publish Publish a message to a topic health Query the health of a service stats Query the stats of a service list List items in registry register Register an item in the registry deregister Deregister an item in the registry get Get item from registry proxy Run the micro proxy new Create a new micro service by specifying a directory path relative to your $GOPATH web Run the micro web appGLOBAL OPTIONS: --client Client for go-micro; rpc [$MICRO_CLIENT] --client_request_timeout Sets the client request timeout. e.g 500ms, 5s, 1m. Default: 5s [$MICRO_CLIENT_REQUEST_TIMEOUT] --client_retries &quot;0&quot; Sets the client retries. Default: 1 [$MICRO_CLIENT_RETRIES] --client_pool_size &quot;0&quot; Sets the client connection pool size. Default: 1 [$MICRO_CLIENT_POOL_SIZE] --client_pool_ttl Sets the client connection pool ttl. e.g 500ms, 5s, 1m. Default: 1m [$MICRO_CLIENT_POOL_TTL] --register_ttl &quot;0&quot; Register TTL in seconds [$MICRO_REGISTER_TTL] --register_interval &quot;0&quot; Register interval in seconds [$MICRO_REGISTER_INTERVAL] --server Server for go-micro; rpc [$MICRO_SERVER] --server_name Name of the server. go.micro.srv.example [$MICRO_SERVER_NAME] --server_version Version of the server. 1.1.0 [$MICRO_SERVER_VERSION] --server_id Id of the server. Auto-generated if not specified [$MICRO_SERVER_ID] --server_address Bind address for the server. 127.0.0.1:8080 [$MICRO_SERVER_ADDRESS] --server_advertise Used instead of the server_address when registering with discovery. 127.0.0.1:8080 [$MICRO_SERVER_ADVERTISE] --server_metadata [--server_metadata option --server_metadata option] A list of key-value pairs defining metadata. version=1.0.0 [$MICRO_SERVER_METADATA] --broker Broker for pub/sub. http, nats, rabbitmq [$MICRO_BROKER] --broker_address Comma-separated list of broker addresses [$MICRO_BROKER_ADDRESS] --registry Registry for discovery. consul, mdns [$MICRO_REGISTRY] --registry_address Comma-separated list of registry addresses [$MICRO_REGISTRY_ADDRESS] --selector &quot;cache&quot; Selector used to pick nodes for querying [$MICRO_SELECTOR] --transport Transport mechanism used; http [$MICRO_TRANSPORT] --transport_address Comma-separated list of transport addresses [$MICRO_TRANSPORT_ADDRESS] --enable_acme Enables ACME support via Let&apos;s Encrypt. ACME hosts should also be specified. [$MICRO_ENABLE_ACME] --acme_hosts Comma separated list of hostnames to manage ACME certs for [$MICRO_ACME_HOSTS] --enable_tls Enable TLS support. Expects cert and key file to be specified [$MICRO_ENABLE_TLS] --tls_cert_file Path to the TLS Certificate file [$MICRO_TLS_CERT_FILE] --tls_key_file Path to the TLS Key file [$MICRO_TLS_KEY_FILE] --tls_client_ca_file Path to the TLS CA file to verify clients against [$MICRO_TLS_CLIENT_CA_FILE] --api_address Set the api address e.g 0.0.0.0:8080 [$MICRO_API_ADDRESS] --proxy_address Proxy requests via the HTTP address specified [$MICRO_PROXY_ADDRESS] --web_address Set the web UI address e.g 0.0.0.0:8082 [$MICRO_WEB_ADDRESS] --api_handler Specify the request handler to be used for mapping HTTP requests to services; &#123;api, proxy, rpc&#125; [$MICRO_API_HANDLER] --api_namespace Set the namespace used by the API e.g. com.example.api [$MICRO_API_NAMESPACE] --web_namespace Set the namespace used by the Web proxy e.g. com.example.web [$MICRO_WEB_NAMESPACE] --api_cors Comma separated whitelist of allowed origins for CORS [$MICRO_API_CORS] --web_cors Comma separated whitelist of allowed origins for CORS [$MICRO_WEB_CORS] --proxy_cors Comma separated whitelist of allowed origins for CORS [$MICRO_PROXY_CORS] --enable_stats Enable stats [$MICRO_ENABLE_STATS] --help, -h show help --version print the version 问题使用micro toolkit，安装其他插件，第一次build缺少相关包，go get 下来，build成功之后运行命令，报如下错误： 12345panic: /debug/requests is already registered. You may have two independent copies of golang.org/x/net/trace in your binary, trying to maintain separate state. This may involve a vendored copy of golang.org/x/net/trace.goroutine 1 [running]:go.etcd.io/etcd/vendor/golang.org/x/net/trace.init.0() /Users/doublesouth/Documents/mycode/golang/lib/src/go.etcd.io/etcd/vendor/golang.org/x/net/trace/trace.go:116 +0x16c 解决方法参考该链接：https://github.com/etcd-io/etcd/issues/9357#issuecomment-377560659 使用 手动取消注册 1micro deregister service '&#123;"name":"&lt;service.name&gt;","version":"&lt;service.version&gt;","nodes":[&#123;"id":"&lt;node.id&gt;"&#125;]&#125;' 如何使用安装服务注册发现中心本地使用docker安装consul： 本地安装docker 运行 docker pull consul 命令从docker hub上拉取最新官方consul镜像 运行 docker run -d --name=local-consul -e CONSUL_BIND_INTERFACE=eth0 -p 8500:8500 consul 命令启动docker容器，需要暴露8500端口，否则本地服务无法注册到consul 服务端1234567891011121314151617181920212223242526type HelloWorld struct &#123; &#125;// 实现hello_world service中的Hello方法func (g *HelloWorld) Hello(ctx context.Context, req *hello_world.HelloRequest, rsp *hello_world.HelloResponse) error &#123; rsp.Greeting = "Hello World: " + req.Name return nil&#125;func main() &#123; service := micro.NewService( micro.Name("hello_world"), micro.Version("latest"), micro.Metadata(map[string]string&#123; "type": "helloworld", &#125;), ) service.Init() hello_world.RegisterHelloWorldHandler(service.Server(), new(HelloWorld)) if err := service.Run(); err != nil &#123; fmt.Println(err) &#125;&#125; 客户端12345678910111213141516171819202122func main() &#123; service := micro.NewService( micro.Name("hello_world"), micro.Version("latest"), micro.Metadata(map[string]string&#123; "type": "helloworld", &#125;), ) service.Init() greeter := hello_world.NewHelloWorldClient("hello_world", service.Client()) rsp, err := greeter.Hello(context.TODO(), &amp;hello_world.HelloRequest&#123;Name: "Alice"&#125;) if err != nil &#123; fmt.Println(err) return &#125; fmt.Println(rsp.Greeting)&#125; 踩过的坑 go-micro框架客户端连接池大小配置不是只建这么多的连接，源码中的处理机制是每次发起客户端请求首先检查池中有没有连接，如果没有连接会直接新建一个连接发起请求，连接用完释放连接的时候会检查池中的连接数是达到配置的连接数，如果达到配置的连接数直接关闭该连接，如果未达到才将该连接放到池中。这就会导致一个问题，如果请求量过大会导致连接一直在创建，最终会报 too many open files 错误。 下面是go-micro框架中client端获取连接和释放连接的源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 获取连接func (p *pool) getConn(addr string, tr transport.Transport, opts ...transport.DialOption) (*poolConn, error) &#123; p.Lock() conns := p.conns[addr] now := time.Now().Unix() // while we have conns check age and then return one // otherwise we'll create a new conn // 1. 首先检查池中可用连接数是否大于1 for len(conns) &gt; 0 &#123; conn := conns[len(conns)-1] conns = conns[:len(conns)-1] p.conns[addr] = conns // if conn is old kill it and move on if d := now - conn.created; d &gt; p.ttl &#123; conn.Client.Close() continue &#125; // we got a good conn, lets unlock and return it p.Unlock() // 2. 直接返回池中连接 return conn, nil &#125; p.Unlock() // create new conn // 3. 如果池中没有连接了，这时新建一个连接并返回 c, err := tr.Dial(addr, opts...) if err != nil &#123; return nil, err &#125; return &amp;poolConn&#123;c, time.Now().Unix()&#125;, nil&#125;// 释放连接func (p *pool) release(addr string, conn *poolConn, err error) &#123; // don't store the conn if it has errored if err != nil &#123; conn.Client.Close() return &#125; // otherwise put it back for reuse p.Lock() conns := p.conns[addr] // 1. 检查池中连接数是否已达到最大，如果达到最大直接关闭连接 if len(conns) &gt;= p.size &#123; p.Unlock() conn.Client.Close() return &#125; // 2. 未达到池中最大连接数将该连接放入池中 p.conns[addr] = append(conns, conn) p.Unlock()&#125; 客户端配置register直接放到main方法获取测试用例中都可以调用到服务端，但是本地同样启个服务端然后在服务里面配置客户端register发现未生效，一直使用默认的consul。 本地测试代码如下： 12345678910111213141516171819202122232425// 这种方式在测试用例中是可以调用成功的// 但是如果和server一起启动，就会初始化失败，使用的register始终都是默认的consulfunc TestClient(t *testing.T) &#123; var c client.Client r := etcdv3.NewRegistry(registry.Addrs("127.0.0.1:2379")) c = client.NewClient() c.Init(client.Selector( selector.NewSelector(selector.Registry(r))), client.PoolSize(100), //连接池大小 client.PoolTTL(5*time.Minute), //长连接缓存时间 client.Retries(3), //重试次数 client.RequestTimeout(30*time.Second), //请求超时 client.DialTimeout(2*time.Second), //客户端连接超时 client.Transport(tcp.NewTransport()), ) Client = service.NewDemoService("demo.service", c) rsp, err := Client.Do(context.TODO(), &amp;Request&#123; Say: "hello", &#125;) if err != nil &#123; t.Errorf("err %v\n", err) &#125;&#125; 这篇博客只是关于go-micro的一个简单介绍以及入门使用，笔者也在学习阶段，随着研究的深入也会分享更多关于go-micro的只是给大家。 参考文档Micro Documentation[go-micro]Micro Documentation[function]Micro examples repositorygo-micro 框架介绍]]></content>
      <categories>
        <category>go-micro</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>go-micro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[glide踩坑记]]></title>
    <url>%2F2018%2F12%2F10%2Fglide%E8%B8%A9%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[坑位 glide 我就不做过多介绍了，它是golang的包管理工具之一，由于该工具github上面不在维护，官方也推荐使用dep，所以之前也使用过dep，但是由于 dep 一直拉取不了 golang.org/x 相关依赖，无奈只能又切回 glide。 坑位 拉取 golang.org/x 相关包同样失败，报 Cannot detect VCS 解决方案 12345678// 替换拉取镜像glide mirror set https://golang.org/x/mobile https://github.com/golang/mobile --vcs gitglide mirror set https://golang.org/x/crypto https://github.com/golang/crypto --vcs gitglide mirror set https://golang.org/x/net https://github.com/golang/net --vcs gitglide mirror set https://golang.org/x/tools https://github.com/golang/tools --vcs gitglide mirror set https://golang.org/x/text https://github.com/golang/text --vcs gitglide mirror set https://golang.org/x/image https://github.com/golang/image --vcs gitglide mirror set https://golang.org/x/sys https://github.com/golang/sys --vcs git 私库的包拉取不了 解决方案 12// 同样替换拉取镜像glide mirror set [本地代码中import的包名,例如：test/keng] [对应私库的地址（http://host/test/keng] --vcs git 无法拉取子包 假设你要拉取的包在glide.yaml中配置如下： 1- package: golang.org/x/net/context 此时同样会报 Cannot detect VCS，因为不支持拉取子包 解决方案 修改glide.yaml中的配置如下： 123- package: golang.org/x/net subpackages: - context]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>glide</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[goland debug 报 include nested too deeply 问题排查]]></title>
    <url>%2F2018%2F11%2F29%2Fgoland%E8%B0%83%E8%AF%95(debug)%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[环境说明系统：MacOS10.14.1goland版本：2018.2.2golang版本：go1.11.2 darwin/amd64 问题描述当使用goland debug调试代码时，首先要开始编译，编译会报如下错误： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228GOROOT=/usr/local/Cellar/go/1.11/libexec #gosetupGOPATH=/path/to/golang/lib:/path/to/golang/workspace #gosetup/usr/local/Cellar/go/1.11/libexec/bin/go build -o /private/var/folders/xs/lp65n5c92gb76wj4zllw1dmr0000gp/T/___go_build_main_go -gcflags &quot;all=-N -l&quot; /path/to/main.go #gosetup# runtime/cgoIn file included from _cgo_export.c:3:In file included from /usr/include/stdlib.h:66:In file included from /usr/include/sys/wait.h:110:In file included from /usr/include/sys/resource.h:72:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:In file included from /usr/local/include/stdint.h:59:/usr/local/include/stdint.h:2:10: error: #include nested too deeply/usr/local/include/stdint.h:59:11: error: #include nested too deeply/usr/local/include/stdint.h:72:11: error: #include nested too deeply/usr/local/include/stdint.h:76:10: error: #include nested too deeply/usr/local/include/stdint.h:82:11: error: #include nested too deeplyIn file included from _cgo_export.c:3:In file included from /usr/include/stdlib.h:66:In file included from /usr/include/sys/wait.h:110:/usr/include/sys/resource.h:197:2: error: unknown type name &apos;uint64_t&apos;/usr/include/sys/resource.h:198:2: error: unknown type name &apos;uint64_t&apos;/usr/include/sys/resource.h:199:2: error: unknown type name &apos;uint64_t&apos;/usr/include/sys/resource.h:200:2: error: unknown type name &apos;uint64_t&apos;/usr/include/sys/resource.h:201:2: error: unknown type name &apos;uint64_t&apos;/usr/include/sys/resource.h:202:2: error: unknown type name &apos;uint64_t&apos;/usr/include/sys/resource.h:203:2: error: unknown type name &apos;uint64_t&apos;/usr/include/sys/resource.h:204:2: error: unknown type name &apos;uint64_t&apos;/usr/include/sys/resource.h:205:2: error: unknown type name &apos;uint64_t&apos;/usr/include/sys/resource.h:206:2: error: unknown type name &apos;uint64_t&apos;/usr/include/sys/resource.h:211:2: error: unknown type name &apos;uint64_t&apos;/usr/include/sys/resource.h:212:2: error: unknown type name &apos;uint64_t&apos;/usr/include/sys/resource.h:213:2: error: unknown type name &apos;uint64_t&apos;/usr/include/sys/resource.h:214:2: error: unknown type name &apos;uint64_t&apos;fatal error: too many errors emitted, stopping now [-ferror-limit=]Compilation finished with exit code 2 正常run启动不会报该错误，经过对比发现正常run的时候执行的build命令如下： 1/usr/local/Cellar/go/1.11/libexec/bin/go build -i -o /private/var/folders/xs/lp65n5c92gb76wj4zllw1dmr0000gp/T/___go_build_main_go /path/to/main.go #gosetup 区别就是debug时候会多 -gcflags “all=-N -l” 参数，加了这个参数就会报错。 解决方案网上也搜索了很多关于加这个参数报错的原因，没有具体的解决方案。后来通过搜索错误日志里面的 error: #include nested too deeply 这个描述，终于找到解决方案，方法如下： 12mkdir /tmp/includesbrew doctor 2&gt;&amp;1 | grep &quot;/usr/local/include&quot; | awk &apos;&#123;$1=$1;print&#125;&apos; | xargs -I _ mv _ /tmp/includes 也是瞎猫碰到死耗子解决了，把这个问题分享出来希望对遇到的人有帮助。]]></content>
      <categories>
        <category>golang</category>
        <category>goland</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>goland</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用feign上传下载文件扩展包填坑记]]></title>
    <url>%2F2018%2F04%2F04%2F%E4%BD%BF%E7%94%A8fegin%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%8C%85%E5%A1%AB%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[问题描述先把有坑的代码贴上：12345678910//...上下文我就省略了，把有问题的代码段贴出来InputStream inputStream = null;inputStream = fresp.body().asInputStream();FileTypeJudger.FileInfo fileInfo = fileTypeJudger.judgeToFileInfo(inputStream);mimeType = fileInfo.getMimeType();// 必须将游标设置到起始位置，才能输出完整的文件流inputStream.reset(); //这里就是有坑的地方//... 以上代码在最后一行会抛出如下异常：1java.io.IOException: mark/reset not supported 但是我在开发和测试环境都验证过，fresp.body().asInputStream()返回的是ByteArrayInputStream类型，也就是说最后一行是支持reset操作的。 排查记录 查看feign源码发现asInputStream()方法有两个实现，分别是ByteArrayBody和InputStreamBody，源码如下： 1234567891011// ByteArrayBody实现@Overridepublic InputStream asInputStream() throws IOException &#123; return new ByteArrayInputStream(data);&#125;// InputStreamBody实现@Overridepublic InputStream asInputStream() throws IOException &#123; return inputStream;&#125; 可以看出只有调用InputStreamBody实现的asInputStream()方法才会出现上面的异常。 然后在本地发起请求，开启debug模式，一步一步跟发现没有问题，每次都是走到ByteArrayBody，这让我郁闷了很长时间啊。 然后尝试跟踪ByteArrayInputStream实例中传递的data的初始化流程。发现是在ByteArrayBody类的构造函数中初始化的。 1234// 构造函数public ByteArrayBody(byte[] data) &#123; this.data = data;&#125; 再跟踪构造函数，发现在orNull()方法中被调用了 1234567// orNull 方法private static Body orNull(byte[] data) &#123; if (data == null) &#123; return null; &#125; return new ByteArrayBody(data);&#125; 再跟踪orNull()方法，发现在Response.Builder类中的被调用，调用方法如下： 1234public Builder body(byte[] data) &#123; this.body = ByteArrayBody.orNull(data); return this;&#125; 再跟踪body()方法，发现有两个地方会调用，Logger和SynchronousMethodHandler两个类中会调用。 然后先在SynchronousMethodHandler的方法中debug，代码片段如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283@Overridepublic Object invoke(Object[] argv) throws Throwable &#123; RequestTemplate template = buildTemplateFromArgs.create(argv); Retryer retryer = this.retryer.clone(); while (true) &#123; try &#123; return executeAndDecode(template); &#125; catch (RetryableException e) &#123; retryer.continueOrPropagate(e); if (logLevel != Logger.Level.NONE) &#123; logger.logRetry(metadata.configKey(), logLevel); &#125; continue; &#125; &#125;&#125;Object executeAndDecode(RequestTemplate template) throws Throwable &#123; Request request = targetRequest(template); if (logLevel != Logger.Level.NONE) &#123; logger.logRequest(metadata.configKey(), logLevel, request); &#125; Response response; long start = System.nanoTime(); try &#123; response = client.execute(request, options); // ensure the request is set. TODO: remove in Feign 10 response.toBuilder().request(request).build(); &#125; catch (IOException e) &#123; if (logLevel != Logger.Level.NONE) &#123; logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start)); &#125; throw errorExecuting(request, e); &#125; long elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start); boolean shouldClose = true; try &#123; if (logLevel != Logger.Level.NONE) &#123; response = logger.logAndRebufferResponse(metadata.configKey(), logLevel, response, elapsedTime); // ensure the request is set. TODO: remove in Feign 10 response.toBuilder().request(request).build(); &#125; if (Response.class == metadata.returnType()) &#123; if (response.body() == null) &#123; return response; &#125; if (response.body().length() == null || response.body().length() &gt; MAX_RESPONSE_BUFFER_SIZE) &#123; shouldClose = false; return response; &#125; // Ensure the response body is disconnected byte[] bodyData = Util.toByteArray(response.body().asInputStream()); // 此处就是调用body方法的地方，断点打到这里，在实际debug过程中发现并没有走到这里 return response.toBuilder().body(bodyData).build(); &#125; if (response.status() &gt;= 200 &amp;&amp; response.status() &lt; 300) &#123; if (void.class == metadata.returnType()) &#123; return null; &#125; else &#123; return decode(response); &#125; &#125; else if (decode404 &amp;&amp; response.status() == 404 &amp;&amp; void.class != metadata.returnType()) &#123; return decode(response); &#125; else &#123; throw errorDecoder.decode(metadata.configKey(), response); &#125; &#125; catch (IOException e) &#123; if (logLevel != Logger.Level.NONE) &#123; logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime); &#125; throw errorReading(request, response, e); &#125; finally &#123; if (shouldClose) &#123; ensureClosed(response.body()); &#125; &#125;&#125; 然后在Logger的方法中debug，代码片段如下： 123456789101112131415161718192021222324252627282930313233343536protected Response logAndRebufferResponse(String configKey, Level logLevel, Response response, long elapsedTime) throws IOException &#123; String reason = response.reason() != null &amp;&amp; logLevel.compareTo(Level.NONE) &gt; 0 ? " " + response.reason() : ""; int status = response.status(); log(configKey, "&lt;--- HTTP/1.1 %s%s (%sms)", status, reason, elapsedTime); if (logLevel.ordinal() &gt;= Level.HEADERS.ordinal()) &#123; for (String field : response.headers().keySet()) &#123; for (String value : valuesOrEmpty(response.headers(), field)) &#123; log(configKey, "%s: %s", field, value); &#125; &#125; int bodyLength = 0; if (response.body() != null &amp;&amp; !(status == 204 || status == 205)) &#123; // HTTP 204 No Content "...response MUST NOT include a message-body" // HTTP 205 Reset Content "...response MUST NOT include an entity" if (logLevel.ordinal() &gt;= Level.FULL.ordinal()) &#123; log(configKey, ""); // CRLF &#125; byte[] bodyData = Util.toByteArray(response.body().asInputStream()); bodyLength = bodyData.length; if (logLevel.ordinal() &gt;= Level.FULL.ordinal() &amp;&amp; bodyLength &gt; 0) &#123; log(configKey, "%s", decodeOrDefault(bodyData, UTF_8, "Binary data")); &#125; log(configKey, "&lt;--- END HTTP (%s-byte body)", bodyLength); // 此处会调用body方法，并且我在本地调试的时候确实会走到此处 return response.toBuilder().body(bodyData).build(); &#125; else &#123; log(configKey, "&lt;--- END HTTP (%s-byte body)", bodyLength); &#125; &#125; return response;&#125; 最后发现，原来我之前在开发和测试环境一直配置的日志打印级别都是debug，feign中的日志只有配置了debug级别才会输出，上面的代码其实就是当判断需要输出日志时，会先把输入流转成byte array缓存起来，并且会封装成ByteArrayBody方便后续复用该流。生产上面配置的日志级别是info，所以会封装成InputStreamBody，也就导致后续获取的输入流是不支持mark的。 解决方案123456789101112131415//...上下文我就省略了，把有问题的代码段贴出来InputStream inputStream = null;inputStream = fresp.body().asInputStream();Util.checkNotNull(inputStream, "inputstream from edfs is null");// 校验流是否支持标记if (!inputStream.markSupported()) &#123; inputStream = new ByteArrayInputStream(Util.toByteArray(inputStream));&#125;FileTypeJudger.FileInfo fileInfo = fileTypeJudger.judgeToFileInfo(inputStream);mimeType = fileInfo.getMimeType();// 必须将游标设置到起始位置，才能输出完整的文件流inputStream.reset();//...]]></content>
      <categories>
        <category>feign</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>feign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八大排序算法的java实现]]></title>
    <url>%2F2017%2F02%2F17%2F8-sort-arithmetic-of-java%2F</url>
    <content type="text"><![CDATA[每当提到算法，自然少不了各种排序算法，例如冒泡排序，快速排序等等。这篇文章将会介绍用java来实现各种排序算法，一来是自己再巩固一下这一块知识的，二来是将这块知识分享给大家，希望大家和我一起进步。 插入排序 基本思想：假设有一组个数为n的数，从第二数开始，按照比较规则插入到之前的数中，这样前面两个数就已经是排好序的，然后在从第三个数开始按照同样的规则插入到之前的数中，依次类推直到操作到第n个数。 下面是具体实现源码：123456789101112131415public static void insertionSort(int[] arr) &#123; int j; for(int i = 1; i &lt; arr.length; i++) &#123; int tmp = arr[i]; for(j = i; j &gt; 0; j--) &#123; if ( tmp &lt; arr[j - 1]) &#123; arr[j] = arr[j - 1]; &#125; else &#123; break; &#125; &#125; arr[j] = tmp; &#125;&#125; 希尔排序 基本思想：算法先将要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。 下面是具体实现源码：1234567891011121314151617181920public static void shellSort(int[] arr) &#123; int d1 = arr.length; while (true) &#123; d1 = (int) Math.ceil(d1 / 2); int d = d1; for (int x = 0; x &lt; d; x++) &#123; for (int i = x + d;i &lt; arr.length;i += d)&#123; int j = i - d; int temp = arr[i]; for (; j &gt;= 0 &amp;&amp; temp &lt; arr[j]; j -= d) &#123; arr[j+d] =arr[j]; &#125; arr[j+d] = temp; &#125; &#125; if (d == 1) &#123; break; &#125; &#125;&#125; 简单选择排序 基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。 下面是具体实现源码：1234567891011public static void selectSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[i]) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125; &#125; &#125;&#125; 堆排序 基本思想：堆排序是一种树形选择排序，是对直接选择排序的有效改进。堆的定义如下：具有n个元素的序列（h1,h2,…,hn),当且仅当满足（hi&gt;=h2i,hi&gt;=2i+1）或（hi&lt;=h2i,hi&lt;=2i+1） (i=1,2,…,n/2)时称之为堆。在这里只讨论满足前者条件的堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。完全二叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。 下面是具体实现源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class HeapSort &#123; public void heapSort(int[] a) &#123; int arrayLength = a.length; //循环建堆 for(int i = 0; i &lt; arrayLength - 1; i++)&#123; //建堆 buildMaxHeap(a, arrayLength - 1 - i); //交换堆顶和最后一个元素 swap(a, 0, arrayLength - 1 - i); &#125; &#125; //交换位置 private void swap(int[] data, int i, int j) &#123; int tmp = data[i]; data[i] = data[j]; data[j] = tmp; &#125; //建堆 private void buildMaxHeap(int[] data, int lastIndex) &#123; //从lastIndex处节点（最后一个节点）的父节点开始 for (int i = (lastIndex - 1) / 2; i &gt;= 0; i--) &#123; //k保存正在判断的节点 int k = i; //如果当前k节点的子节点存在 while (k * 2 + 1 &lt;= lastIndex) &#123; //k节点的左子节点的索引 int biggerIndex = 2 * k + 1; //如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在 if (biggerIndex &lt; lastIndex) &#123; //若果右子节点的值较大 if (data[biggerIndex] &lt; data[biggerIndex + 1]) &#123; //biggerIndex总是记录较大子节点的索引 biggerIndex++; &#125; &#125; //如果k节点的值小于其较大的子节点的值 if (data[k] &lt; data[biggerIndex]) &#123; //交换他们 swap(data, k, biggerIndex); //将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值 k = biggerIndex; &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125; 冒泡排序 基本思想：假设有一个长度为n的数组，从第一个位置开始，每两个相邻的位置的数值进行比较，如果前面一个位置的数值比后面一个位置的数值大，就交换这两个位置的数值，当最后一对数比较完毕之后，最后一个位置的数值就是最大值。然后我们再以相同的步骤操作数组中除了最后一个位置的所有值，直到没有任何一对数值需要比较。 下面是具体实现源码：1234567891011public static void bubbleSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; &#125; &#125;&#125; 快速排序 基本思想：假设有一个长度为n的集合，将中间的元素作为中轴，把集合中的所有小于该中轴的元素放在中轴左边，把集合中的所有大于该中轴的元素放在右边，然后在以相同的逻辑分别处理中轴左边和右边的集合，依次递归，直到中轴左边和右边的元素个数都为1。 下面是具体实现代码：1234567891011121314151617181920212223242526public static void fastSort(List&lt;Integer&gt; items) &#123; if (items.size() &gt; 1) &#123; List&lt;Integer&gt; smaller = new ArrayList&lt;&gt;(); List&lt;Integer&gt; same = new ArrayList&lt;&gt;(); List&lt;Integer&gt; larger = new ArrayList&lt;&gt;(); Integer chosenItem = items.get(items.size() / 2); for (Integer item : items) &#123; if (item &lt; chosenItem) &#123; smaller.add(item); &#125; else if (item &gt; chosenItem) &#123; larger.add(item); &#125; else &#123; same.add(item); &#125; &#125; fastSort(smaller); fastSort(larger); items.clear(); items.addAll(smaller); items.addAll(same); items.addAll(larger); &#125;&#125; 归并排序 基本思想：归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。 下面是具体实现代码：1234567891011121314151617181920212223242526272829303132333435public class MergeSort &#123; public static void sort(int data[], int start, int end) &#123; if (start &lt; end) &#123; int mid = (start + end) / 2; sort(data, start, mid); sort(data, mid + 1, end); merge(data, start, mid, end); &#125; &#125; public static void merge(int data[], int start, int mid, int end) &#123; int temp[] = new int[end - start + 1]; int i = start; int j = mid + 1; int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= end) &#123; if (data[i] &lt; data[j]) &#123; temp[k++] = data[i++]; &#125; else &#123; temp[k++] = data[j++]; &#125; &#125; while (i &lt;= mid) &#123; temp[k++] = data[i++]; &#125; while (j &lt;= end) &#123; temp[k++] = data[j++]; &#125; for (k = 0, i = start; k &lt; temp.length; k++, i++) &#123; data[i] = temp[k]; &#125; &#125;&#125; 基数排序 基本思想：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。 下面是具体实现代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static class radixSort &#123; public void sort(int[] array) &#123; //首先确定排序的趟数; int max = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; &#125; int time = 0; //判断位数; while (max &gt; 0) &#123; max /= 10; time++; &#125; //建立10个队列; List&lt;ArrayList&gt; queue = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; ArrayList&lt;Integer&gt; queue1 = new ArrayList&lt;&gt;(); queue.add(queue1); &#125; //进行time次分配和收集; for (int i = 0; i &lt; time; i++) &#123; //分配数组元素; for (int j = 0; j &lt; array.length; j++) &#123; //得到数字的第time+1位数; int x = array[j] % (int) Math.pow(10, i + 1) / (int) Math.pow(10, i); ArrayList&lt;Integer&gt; queue2 = queue.get(x); queue2.add(array[j]); queue.set(x, queue2); &#125; int count = 0;//元素计数器; //收集队列元素; for (int k = 0; k &lt; 10; k++) &#123; while (queue.get(k).size() &gt; 0) &#123; ArrayList&lt;Integer&gt; queue3 = queue.get(k); array[count] = queue3.get(0); queue3.remove(0); count++; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客从使用Hexo搭建博客开始]]></title>
    <url>%2F2017%2F02%2F04%2Fmy-first-blog-start-with-build-blog-using-hexo%2F</url>
    <content type="text"><![CDATA[Hexo是一款快速、简洁且高效的博客框架，用它来搭建自己的个人博客是一个不错的选择。这篇文章主要介绍我是如何使用该框架来搭建自己的个人博客。 Hexo安装及相关配置安装Hexo安装很简单，mac和windows都有详细的安装教程，这里提供一个hexo官方详细的安装教程链接。 打开本地终端，然后执行以下命令，初始化工作目录123$ hexo init &lt;folder-path&gt;$ cd &lt;folder-path&gt;$ npm install 执行完以上命令之后，工作目录就初始化完成了。 配置进入工作目录会发现有一个_config.yml的文件，配置就是在这个文件中添加和修改的。 这里简单介绍一下几个常用的参数： 参数名 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 你的名字 language 网站使用的语言，例如zh-Hans就是指中文 timezone 网站时区，例如Asia/Shanghai就是指上海时区 theme 网站主题，使用之前需要先安装 avatar 你的头像 favicon 网页tag的小图标 这些知识简单介绍一下，具体的配置说明详见Hexo官方配置说明 Hexo主题Next安装及相关配置安装打开终端，执行如下命令：12$ cd &lt;folder-path&gt;$ git clone https://github.com/iissnan/hexo-theme-next themes/next 命令执行完成之后，编辑_config.yml文件，将theme参数的修改成next。 然后执行如下命令，清除Hexo缓存：1$ hexo clean 配置Next主题也有很多配置参数，这里我还是简单介绍一些常用的： 参数名 描述 scheme 外观配置，支持三种（Muse,Mist,Pisces） language 网站语言，和Hexo中的类似 menu 菜单配置 具体的配置说明详见Next官方配置说明。 将网站托管到github上创建仓库github中创建一个仓库这里就不详细说明了，把几点注意事项说明一下： 仓库必须是public的 仓库名称要以yourname.github.io的格式命名 将本地机器的公钥添加到你的github中 关联本地网站到github仓库中在Hexo的配置文件_config.yml中修改如下配置：1234deploy: type: git repository: &lt;你的github新建的仓库地址&gt; branch: master 修改完成之后，我们可以打开终端执行如下命令：123$ hexo clean$ hexo g$ hexo d 将网站部署到github中。 部署完成之后你可以通过访问 https://yourname.github.io 地址，如果能够访问，说明你在本地配置好的网站已经成功部署到github中了。 如何对本地网站进行版本控制进过如上步骤之后你的网站已经成功部署到github中了，但是如果对你的网站进行版本控制呢？ 我是参考利用git解决hexo博客多PC间同步问题这篇博客的做法：利用oschina的私有仓库来进行版本控制，在网站工作根路径下将该目录重新初始化成本地git仓库，然后将本地仓库提交到oschina的私有仓库中。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
